import base64
import http

import requests
from Crypto.Util.number import bytes_to_long, long_to_bytes
from tqdm import tqdm

# https://github.com/Consensys/gnark-crypto/blob/master/ecc/bls12-381/marshal.go
mMask = 0b111 << 5
mCompressedSmallest = 0b100 << 5
mCompressedLargest = 0b101 << 5


URL = "http://localhost:13337"
MY_URL = "http://localhost:13338"


def is_power_of_two(value: int) -> bool:
    return (value > 0) and (value & (value - 1) == 0)


def reverse_bits(n: int, order: int) -> int:
    assert is_power_of_two(order)
    return int(("{:0" + str(order.bit_length() - 1) + "b}").format(n)[::-1], 2)


def bit_reversal_permutation(sequence):
    return [sequence[reverse_bits(i, len(sequence))] for i in range(len(sequence))]


def evaluate(x: int):
    inp = "{:064x}".format(x)
    r = requests.post(URL + "/admin/eval", json={"input": inp})
    y = bytes_to_long(base64.b64decode(r.json()["claimedValue"]))
    return y


def interpolate(points):
    return R.lagrange_polynomial(points)


def blob_to_polynomial(blob):
    # (F(w^0), F(w^1), ..., F(w^4095))
    points = []
    for i in range(4096):
        element = bytes_to_long(blob[32 * i : 32 * (i + 1)])
        assert element < q
        points.append((roots[i], element))

    blob_poly = interpolate(points)
    return blob_poly


def get_admin_blob():
    r = requests.get(URL + "/admin/blob")
    assert r.status_code == http.HTTPStatus.OK

    blob = base64.b64decode(r.text)
    assert len(blob) == 4096 * 32
    return blob


def get_commitment(blob):
    r = requests.post(MY_URL + "/commit", json={"input": base64.b64encode(blob).decode()})
    assert r.status_code == http.HTTPStatus.OK
    commitment = base64.b64decode(r.json()["commitment"])
    assert len(commitment) == 48
    return deserialize_G1_point(bytearray(commitment))


def deserialize_G1_point(buf):
    # https://github.com/Consensys/gnark-crypto/blob/master/ecc/bls12-381/marshal.go
    assert len(buf) == 48
    mData = buf[0] & mMask
    assert mData in [mCompressedLargest, mCompressedSmallest]
    yParity = mData == mCompressedLargest
    buf[0] &= 0b11111111 - mMask
    x = Integer(bytes_to_long(buf))
    point = E.lift_x(x)
    if yParity:
        y = max(point[1], p - point[1])
    else:
        y = min(point[1], p - point[1])
    return E(x, y)


def serialize_G1_point(point):
    # https://github.com/Consensys/gnark-crypto/blob/master/ecc/bls12-381/marshal.go
    x, y = point[0].lift(), point[1].lift()
    yParity = y > p - y
    buf = bytearray(long_to_bytes(x).rjust(48, b"\x00"))
    buf[0] |= mCompressedLargest if yParity else mCompressedSmallest
    return buf


def forge_proof(tau, commitment, x, y_forged):
    return pow(tau - x, -1, q) * (commitment - y_forged * G1)


def get_flag(x, y, proof):
    inp = "{:064x}".format(x)
    proof_encoded = base64.b64encode(serialize_G1_point(proof)).decode()
    claimed_value_encoded = base64.b64encode(int(y).to_bytes(32, "big")).decode()
    body = {"input": inp, "claimedValue": claimed_value_encoded, "proof": proof_encoded}
    r = requests.post(URL + "/admin/flag", json=body)
    return r.text


def polynomial_to_blob(poly):
    assert poly.degree() == 4095
    blob = b""
    for i in range(4096):
        value = poly.subs(x=roots[i])
        blob += int(value).to_bytes(32, byteorder="big")
    assert len(blob) == 32 * 4096
    return blob


if __name__ == "__main__":
    q = 52435875175126190479447740508185965837690552500527637822603658699938581184513
    FF = IntegerModRing(q)
    R.<x> = PolynomialRing(FF)
    w = FF(
        39033254847818212395286706435128746857159659164139250548781411570340225835782
    )
    assert FF(w) ** 4096 == 1
    roots = [w**i for i in range(4096)]
    # reverse roots:
    # reason: The bit reversal is not needed for simple KZG however it was
    #    implemented to make the step for full dank-sharding easier.
    roots = bit_reversal_permutation(roots)
    # BLS12-381
    p = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
    E = EllipticCurve(IntegerModRing(p), [0, 4])
    # BLS12-381 Generator for curve
    G1 = E(
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569,
    )

    tau = 13371337
    x = 1234

    # admin_blob = get_admin_blob()
    # admin_poly = blob_to_polynomial(admin_blob)

    points = []
    for i in tqdm(range(4096)):
        x = roots[i].lift()
        y = evaluate(x) # /admin/eval
        point = (x, y)
        points.append(point)

    admin_poly = interpolate(points)
    admin_blob = polynomial_to_blob(admin_poly)
    admin_commitment = get_commitment(admin_blob) # /commit

    # y_correct = admin_poly.subs(x=x)
    # proof = forge_proof(tau, admin_commitment, x, y_correct)
    # assert (
    #     get_flag(x, y_correct, proof).strip()
    #     == "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
    # )

    y_forged = 7331
    proof_forged = forge_proof(tau, admin_commitment, x, y_forged)
    flag = get_flag(x, y_forged, proof_forged)
    print(f"{flag = }")
